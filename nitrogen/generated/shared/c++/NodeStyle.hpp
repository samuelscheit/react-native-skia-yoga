///
/// NodeStyle.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `Align` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class Align; }
// Forward declaration of `BoxSizing` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class BoxSizing; }
// Forward declaration of `Direction` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class Direction; }
// Forward declaration of `Display` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class Display; }
// Forward declaration of `FlexDirection` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class FlexDirection; }
// Forward declaration of `FlexWrap` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class FlexWrap; }
// Forward declaration of `JustifyContent` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class JustifyContent; }
// Forward declaration of `Overflow` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class Overflow; }
// Forward declaration of `Position` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class Position; }
// Forward declaration of `SkPoint` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct SkPoint; }
// Forward declaration of `StrokeCap` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class StrokeCap; }
// Forward declaration of `StrokeJoin` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class StrokeJoin; }
// Forward declaration of `BlendMode` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { enum class BlendMode; }
// Forward declaration of `TransformRotateX` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformRotateX; }
// Forward declaration of `TransformRotateY` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformRotateY; }
// Forward declaration of `TransformRotateZ` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformRotateZ; }
// Forward declaration of `TransformScale` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformScale; }
// Forward declaration of `TransformScaleX` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformScaleX; }
// Forward declaration of `TransformScaleY` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformScaleY; }
// Forward declaration of `TransformTranslateX` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformTranslateX; }
// Forward declaration of `TransformTranslateY` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformTranslateY; }
// Forward declaration of `TransformSkewX` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformSkewX; }
// Forward declaration of `TransformSkewY` to properly resolve imports.
namespace margelo::nitro::RNSkiaYoga { struct TransformSkewY; }

#include "Align.hpp"
#include <optional>
#include <string>
#include <variant>
#include "BoxSizing.hpp"
#include "Direction.hpp"
#include "Display.hpp"
#include "FlexDirection.hpp"
#include "FlexWrap.hpp"
#include "JustifyContent.hpp"
#include "Overflow.hpp"
#include "Position.hpp"
#include "JSIConverter+SkPaint.hpp"
#include "SkPoint.hpp"
#include "StrokeCap.hpp"
#include "StrokeJoin.hpp"
#include "BlendMode.hpp"
#include "TransformRotateX.hpp"
#include "TransformRotateY.hpp"
#include "TransformRotateZ.hpp"
#include "TransformScale.hpp"
#include "TransformScaleX.hpp"
#include "TransformScaleY.hpp"
#include "TransformTranslateX.hpp"
#include "TransformTranslateY.hpp"
#include "TransformSkewX.hpp"
#include "TransformSkewY.hpp"
#include <vector>
#include <tuple>
#include "JSIConverter+SkMatrix.hpp"
#include "JSIConverter+SkPath.hpp"
#include "JSIConverter+SkRRect.hpp"
#include "JSIConverter+SkRect.hpp"

namespace margelo::nitro::RNSkiaYoga {

  /**
   * A struct which can be represented as a JavaScript object (NodeStyle).
   */
  struct NodeStyle {
  public:
    std::optional<Align> alignContent     SWIFT_PRIVATE;
    std::optional<Align> alignItems     SWIFT_PRIVATE;
    std::optional<Align> alignSelf     SWIFT_PRIVATE;
    std::optional<double> aspectRatio     SWIFT_PRIVATE;
    std::optional<double> borderBottomWidth     SWIFT_PRIVATE;
    std::optional<double> borderEndWidth     SWIFT_PRIVATE;
    std::optional<double> borderLeftWidth     SWIFT_PRIVATE;
    std::optional<double> borderRightWidth     SWIFT_PRIVATE;
    std::optional<double> borderStartWidth     SWIFT_PRIVATE;
    std::optional<double> borderTopWidth     SWIFT_PRIVATE;
    std::optional<double> borderWidth     SWIFT_PRIVATE;
    std::optional<double> borderHorizontalWidth     SWIFT_PRIVATE;
    std::optional<double> borderVerticalWidth     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> bottom     SWIFT_PRIVATE;
    std::optional<BoxSizing> boxSizing     SWIFT_PRIVATE;
    std::optional<Direction> direction     SWIFT_PRIVATE;
    std::optional<Display> display     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> end     SWIFT_PRIVATE;
    std::optional<double> flex     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> flexBasis     SWIFT_PRIVATE;
    std::optional<FlexDirection> flexDirection     SWIFT_PRIVATE;
    std::optional<double> rowGap     SWIFT_PRIVATE;
    std::optional<double> gap     SWIFT_PRIVATE;
    std::optional<double> columnGap     SWIFT_PRIVATE;
    std::optional<double> flexGrow     SWIFT_PRIVATE;
    std::optional<double> flexShrink     SWIFT_PRIVATE;
    std::optional<FlexWrap> flexWrap     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> height     SWIFT_PRIVATE;
    std::optional<JustifyContent> justifyContent     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> left     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> margin     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> marginBottom     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> marginEnd     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> marginLeft     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> marginRight     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> marginStart     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> marginTop     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> marginHorizontal     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> marginVertical     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> maxHeight     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> maxWidth     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> minHeight     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> minWidth     SWIFT_PRIVATE;
    std::optional<Overflow> overflow     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> padding     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> paddingBottom     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> paddingEnd     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> paddingLeft     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> paddingRight     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> paddingStart     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> paddingTop     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> paddingHorizontal     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> paddingVertical     SWIFT_PRIVATE;
    std::optional<Position> position     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> right     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> start     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> top     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> insetHorizontal     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> insetVertical     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> inset     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, double>> width     SWIFT_PRIVATE;
    std::optional<std::variant<std::string, SkPaint>> backgroundColor     SWIFT_PRIVATE;
    std::optional<double> borderRadius     SWIFT_PRIVATE;
    std::optional<std::variant<double, SkPoint>> borderBottomLeftRadius     SWIFT_PRIVATE;
    std::optional<std::variant<double, SkPoint>> borderBottomRightRadius     SWIFT_PRIVATE;
    std::optional<std::variant<double, SkPoint>> borderTopLeftRadius     SWIFT_PRIVATE;
    std::optional<std::variant<double, SkPoint>> borderTopRightRadius     SWIFT_PRIVATE;
    std::optional<StrokeCap> strokeCap     SWIFT_PRIVATE;
    std::optional<StrokeJoin> strokeJoin     SWIFT_PRIVATE;
    std::optional<double> strokeMiter     SWIFT_PRIVATE;
    std::optional<BlendMode> blendMode     SWIFT_PRIVATE;
    std::optional<bool> antiaAlias     SWIFT_PRIVATE;
    std::optional<bool> dither     SWIFT_PRIVATE;
    std::optional<double> opacity     SWIFT_PRIVATE;
    std::optional<std::vector<std::variant<TransformRotateX, TransformRotateY, TransformRotateZ, TransformScale, TransformScaleX, TransformScaleY, TransformTranslateX, TransformTranslateY, TransformSkewX, TransformSkewY>>> transform     SWIFT_PRIVATE;
    std::optional<std::tuple<double, double>> origin     SWIFT_PRIVATE;
    std::optional<shared_ptr<SkMatrix>> matrix     SWIFT_PRIVATE;
    std::optional<std::variant<SkPath, SkRRect, SkRect>> clip     SWIFT_PRIVATE;
    std::optional<bool> invertClip     SWIFT_PRIVATE;

  public:
    NodeStyle() = default;
    explicit NodeStyle(std::optional<Align> alignContent, std::optional<Align> alignItems, std::optional<Align> alignSelf, std::optional<double> aspectRatio, std::optional<double> borderBottomWidth, std::optional<double> borderEndWidth, std::optional<double> borderLeftWidth, std::optional<double> borderRightWidth, std::optional<double> borderStartWidth, std::optional<double> borderTopWidth, std::optional<double> borderWidth, std::optional<double> borderHorizontalWidth, std::optional<double> borderVerticalWidth, std::optional<std::variant<std::string, double>> bottom, std::optional<BoxSizing> boxSizing, std::optional<Direction> direction, std::optional<Display> display, std::optional<std::variant<std::string, double>> end, std::optional<double> flex, std::optional<std::variant<std::string, double>> flexBasis, std::optional<FlexDirection> flexDirection, std::optional<double> rowGap, std::optional<double> gap, std::optional<double> columnGap, std::optional<double> flexGrow, std::optional<double> flexShrink, std::optional<FlexWrap> flexWrap, std::optional<std::variant<std::string, double>> height, std::optional<JustifyContent> justifyContent, std::optional<std::variant<std::string, double>> left, std::optional<std::variant<std::string, double>> margin, std::optional<std::variant<std::string, double>> marginBottom, std::optional<std::variant<std::string, double>> marginEnd, std::optional<std::variant<std::string, double>> marginLeft, std::optional<std::variant<std::string, double>> marginRight, std::optional<std::variant<std::string, double>> marginStart, std::optional<std::variant<std::string, double>> marginTop, std::optional<std::variant<std::string, double>> marginHorizontal, std::optional<std::variant<std::string, double>> marginVertical, std::optional<std::variant<std::string, double>> maxHeight, std::optional<std::variant<std::string, double>> maxWidth, std::optional<std::variant<std::string, double>> minHeight, std::optional<std::variant<std::string, double>> minWidth, std::optional<Overflow> overflow, std::optional<std::variant<std::string, double>> padding, std::optional<std::variant<std::string, double>> paddingBottom, std::optional<std::variant<std::string, double>> paddingEnd, std::optional<std::variant<std::string, double>> paddingLeft, std::optional<std::variant<std::string, double>> paddingRight, std::optional<std::variant<std::string, double>> paddingStart, std::optional<std::variant<std::string, double>> paddingTop, std::optional<std::variant<std::string, double>> paddingHorizontal, std::optional<std::variant<std::string, double>> paddingVertical, std::optional<Position> position, std::optional<std::variant<std::string, double>> right, std::optional<std::variant<std::string, double>> start, std::optional<std::variant<std::string, double>> top, std::optional<std::variant<std::string, double>> insetHorizontal, std::optional<std::variant<std::string, double>> insetVertical, std::optional<std::variant<std::string, double>> inset, std::optional<std::variant<std::string, double>> width, std::optional<std::variant<std::string, SkPaint>> backgroundColor, std::optional<double> borderRadius, std::optional<std::variant<double, SkPoint>> borderBottomLeftRadius, std::optional<std::variant<double, SkPoint>> borderBottomRightRadius, std::optional<std::variant<double, SkPoint>> borderTopLeftRadius, std::optional<std::variant<double, SkPoint>> borderTopRightRadius, std::optional<StrokeCap> strokeCap, std::optional<StrokeJoin> strokeJoin, std::optional<double> strokeMiter, std::optional<BlendMode> blendMode, std::optional<bool> antiaAlias, std::optional<bool> dither, std::optional<double> opacity, std::optional<std::vector<std::variant<TransformRotateX, TransformRotateY, TransformRotateZ, TransformScale, TransformScaleX, TransformScaleY, TransformTranslateX, TransformTranslateY, TransformSkewX, TransformSkewY>>> transform, std::optional<std::tuple<double, double>> origin, std::optional<shared_ptr<SkMatrix>> matrix, std::optional<std::variant<SkPath, SkRRect, SkRect>> clip, std::optional<bool> invertClip): alignContent(alignContent), alignItems(alignItems), alignSelf(alignSelf), aspectRatio(aspectRatio), borderBottomWidth(borderBottomWidth), borderEndWidth(borderEndWidth), borderLeftWidth(borderLeftWidth), borderRightWidth(borderRightWidth), borderStartWidth(borderStartWidth), borderTopWidth(borderTopWidth), borderWidth(borderWidth), borderHorizontalWidth(borderHorizontalWidth), borderVerticalWidth(borderVerticalWidth), bottom(bottom), boxSizing(boxSizing), direction(direction), display(display), end(end), flex(flex), flexBasis(flexBasis), flexDirection(flexDirection), rowGap(rowGap), gap(gap), columnGap(columnGap), flexGrow(flexGrow), flexShrink(flexShrink), flexWrap(flexWrap), height(height), justifyContent(justifyContent), left(left), margin(margin), marginBottom(marginBottom), marginEnd(marginEnd), marginLeft(marginLeft), marginRight(marginRight), marginStart(marginStart), marginTop(marginTop), marginHorizontal(marginHorizontal), marginVertical(marginVertical), maxHeight(maxHeight), maxWidth(maxWidth), minHeight(minHeight), minWidth(minWidth), overflow(overflow), padding(padding), paddingBottom(paddingBottom), paddingEnd(paddingEnd), paddingLeft(paddingLeft), paddingRight(paddingRight), paddingStart(paddingStart), paddingTop(paddingTop), paddingHorizontal(paddingHorizontal), paddingVertical(paddingVertical), position(position), right(right), start(start), top(top), insetHorizontal(insetHorizontal), insetVertical(insetVertical), inset(inset), width(width), backgroundColor(backgroundColor), borderRadius(borderRadius), borderBottomLeftRadius(borderBottomLeftRadius), borderBottomRightRadius(borderBottomRightRadius), borderTopLeftRadius(borderTopLeftRadius), borderTopRightRadius(borderTopRightRadius), strokeCap(strokeCap), strokeJoin(strokeJoin), strokeMiter(strokeMiter), blendMode(blendMode), antiaAlias(antiaAlias), dither(dither), opacity(opacity), transform(transform), origin(origin), matrix(matrix), clip(clip), invertClip(invertClip) {}
  };

} // namespace margelo::nitro::RNSkiaYoga

namespace margelo::nitro {

  // C++ NodeStyle <> JS NodeStyle (object)
  template <>
  struct JSIConverter<margelo::nitro::RNSkiaYoga::NodeStyle> final {
    static inline margelo::nitro::RNSkiaYoga::NodeStyle fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return margelo::nitro::RNSkiaYoga::NodeStyle(
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::fromJSI(runtime, obj.getProperty(runtime, "alignContent")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::fromJSI(runtime, obj.getProperty(runtime, "alignItems")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::fromJSI(runtime, obj.getProperty(runtime, "alignSelf")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "aspectRatio")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderBottomWidth")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderEndWidth")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderLeftWidth")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderRightWidth")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderStartWidth")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderTopWidth")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderWidth")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderHorizontalWidth")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderVerticalWidth")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "bottom")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::BoxSizing>>::fromJSI(runtime, obj.getProperty(runtime, "boxSizing")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Direction>>::fromJSI(runtime, obj.getProperty(runtime, "direction")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Display>>::fromJSI(runtime, obj.getProperty(runtime, "display")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "end")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "flex")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "flexBasis")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::FlexDirection>>::fromJSI(runtime, obj.getProperty(runtime, "flexDirection")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "rowGap")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "gap")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "columnGap")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "flexGrow")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "flexShrink")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::FlexWrap>>::fromJSI(runtime, obj.getProperty(runtime, "flexWrap")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "height")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::JustifyContent>>::fromJSI(runtime, obj.getProperty(runtime, "justifyContent")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "left")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "margin")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "marginBottom")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "marginEnd")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "marginLeft")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "marginRight")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "marginStart")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "marginTop")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "marginHorizontal")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "marginVertical")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "maxHeight")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "maxWidth")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "minHeight")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "minWidth")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Overflow>>::fromJSI(runtime, obj.getProperty(runtime, "overflow")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "padding")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "paddingBottom")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "paddingEnd")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "paddingLeft")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "paddingRight")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "paddingStart")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "paddingTop")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "paddingHorizontal")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "paddingVertical")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Position>>::fromJSI(runtime, obj.getProperty(runtime, "position")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "right")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "start")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "top")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "insetHorizontal")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "insetVertical")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "inset")),
        JSIConverter<std::optional<std::variant<std::string, double>>>::fromJSI(runtime, obj.getProperty(runtime, "width")),
        JSIConverter<std::optional<std::variant<std::string, SkPaint>>>::fromJSI(runtime, obj.getProperty(runtime, "backgroundColor")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "borderRadius")),
        JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::fromJSI(runtime, obj.getProperty(runtime, "borderBottomLeftRadius")),
        JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::fromJSI(runtime, obj.getProperty(runtime, "borderBottomRightRadius")),
        JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::fromJSI(runtime, obj.getProperty(runtime, "borderTopLeftRadius")),
        JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::fromJSI(runtime, obj.getProperty(runtime, "borderTopRightRadius")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::StrokeCap>>::fromJSI(runtime, obj.getProperty(runtime, "strokeCap")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::StrokeJoin>>::fromJSI(runtime, obj.getProperty(runtime, "strokeJoin")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "strokeMiter")),
        JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::BlendMode>>::fromJSI(runtime, obj.getProperty(runtime, "blendMode")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "antiaAlias")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "dither")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "opacity")),
        JSIConverter<std::optional<std::vector<std::variant<margelo::nitro::RNSkiaYoga::TransformRotateX, margelo::nitro::RNSkiaYoga::TransformRotateY, margelo::nitro::RNSkiaYoga::TransformRotateZ, margelo::nitro::RNSkiaYoga::TransformScale, margelo::nitro::RNSkiaYoga::TransformScaleX, margelo::nitro::RNSkiaYoga::TransformScaleY, margelo::nitro::RNSkiaYoga::TransformTranslateX, margelo::nitro::RNSkiaYoga::TransformTranslateY, margelo::nitro::RNSkiaYoga::TransformSkewX, margelo::nitro::RNSkiaYoga::TransformSkewY>>>>::fromJSI(runtime, obj.getProperty(runtime, "transform")),
        JSIConverter<std::optional<std::tuple<double, double>>>::fromJSI(runtime, obj.getProperty(runtime, "origin")),
        JSIConverter<std::optional<shared_ptr<SkMatrix>>>::fromJSI(runtime, obj.getProperty(runtime, "matrix")),
        JSIConverter<std::optional<std::variant<SkPath, SkRRect, SkRect>>>::fromJSI(runtime, obj.getProperty(runtime, "clip")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "invertClip"))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const margelo::nitro::RNSkiaYoga::NodeStyle& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, "alignContent", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::toJSI(runtime, arg.alignContent));
      obj.setProperty(runtime, "alignItems", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::toJSI(runtime, arg.alignItems));
      obj.setProperty(runtime, "alignSelf", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::toJSI(runtime, arg.alignSelf));
      obj.setProperty(runtime, "aspectRatio", JSIConverter<std::optional<double>>::toJSI(runtime, arg.aspectRatio));
      obj.setProperty(runtime, "borderBottomWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderBottomWidth));
      obj.setProperty(runtime, "borderEndWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderEndWidth));
      obj.setProperty(runtime, "borderLeftWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderLeftWidth));
      obj.setProperty(runtime, "borderRightWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderRightWidth));
      obj.setProperty(runtime, "borderStartWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderStartWidth));
      obj.setProperty(runtime, "borderTopWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderTopWidth));
      obj.setProperty(runtime, "borderWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderWidth));
      obj.setProperty(runtime, "borderHorizontalWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderHorizontalWidth));
      obj.setProperty(runtime, "borderVerticalWidth", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderVerticalWidth));
      obj.setProperty(runtime, "bottom", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.bottom));
      obj.setProperty(runtime, "boxSizing", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::BoxSizing>>::toJSI(runtime, arg.boxSizing));
      obj.setProperty(runtime, "direction", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Direction>>::toJSI(runtime, arg.direction));
      obj.setProperty(runtime, "display", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Display>>::toJSI(runtime, arg.display));
      obj.setProperty(runtime, "end", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.end));
      obj.setProperty(runtime, "flex", JSIConverter<std::optional<double>>::toJSI(runtime, arg.flex));
      obj.setProperty(runtime, "flexBasis", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.flexBasis));
      obj.setProperty(runtime, "flexDirection", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::FlexDirection>>::toJSI(runtime, arg.flexDirection));
      obj.setProperty(runtime, "rowGap", JSIConverter<std::optional<double>>::toJSI(runtime, arg.rowGap));
      obj.setProperty(runtime, "gap", JSIConverter<std::optional<double>>::toJSI(runtime, arg.gap));
      obj.setProperty(runtime, "columnGap", JSIConverter<std::optional<double>>::toJSI(runtime, arg.columnGap));
      obj.setProperty(runtime, "flexGrow", JSIConverter<std::optional<double>>::toJSI(runtime, arg.flexGrow));
      obj.setProperty(runtime, "flexShrink", JSIConverter<std::optional<double>>::toJSI(runtime, arg.flexShrink));
      obj.setProperty(runtime, "flexWrap", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::FlexWrap>>::toJSI(runtime, arg.flexWrap));
      obj.setProperty(runtime, "height", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.height));
      obj.setProperty(runtime, "justifyContent", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::JustifyContent>>::toJSI(runtime, arg.justifyContent));
      obj.setProperty(runtime, "left", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.left));
      obj.setProperty(runtime, "margin", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.margin));
      obj.setProperty(runtime, "marginBottom", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.marginBottom));
      obj.setProperty(runtime, "marginEnd", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.marginEnd));
      obj.setProperty(runtime, "marginLeft", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.marginLeft));
      obj.setProperty(runtime, "marginRight", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.marginRight));
      obj.setProperty(runtime, "marginStart", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.marginStart));
      obj.setProperty(runtime, "marginTop", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.marginTop));
      obj.setProperty(runtime, "marginHorizontal", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.marginHorizontal));
      obj.setProperty(runtime, "marginVertical", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.marginVertical));
      obj.setProperty(runtime, "maxHeight", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.maxHeight));
      obj.setProperty(runtime, "maxWidth", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.maxWidth));
      obj.setProperty(runtime, "minHeight", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.minHeight));
      obj.setProperty(runtime, "minWidth", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.minWidth));
      obj.setProperty(runtime, "overflow", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Overflow>>::toJSI(runtime, arg.overflow));
      obj.setProperty(runtime, "padding", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.padding));
      obj.setProperty(runtime, "paddingBottom", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.paddingBottom));
      obj.setProperty(runtime, "paddingEnd", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.paddingEnd));
      obj.setProperty(runtime, "paddingLeft", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.paddingLeft));
      obj.setProperty(runtime, "paddingRight", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.paddingRight));
      obj.setProperty(runtime, "paddingStart", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.paddingStart));
      obj.setProperty(runtime, "paddingTop", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.paddingTop));
      obj.setProperty(runtime, "paddingHorizontal", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.paddingHorizontal));
      obj.setProperty(runtime, "paddingVertical", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.paddingVertical));
      obj.setProperty(runtime, "position", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Position>>::toJSI(runtime, arg.position));
      obj.setProperty(runtime, "right", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.right));
      obj.setProperty(runtime, "start", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.start));
      obj.setProperty(runtime, "top", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.top));
      obj.setProperty(runtime, "insetHorizontal", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.insetHorizontal));
      obj.setProperty(runtime, "insetVertical", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.insetVertical));
      obj.setProperty(runtime, "inset", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.inset));
      obj.setProperty(runtime, "width", JSIConverter<std::optional<std::variant<std::string, double>>>::toJSI(runtime, arg.width));
      obj.setProperty(runtime, "backgroundColor", JSIConverter<std::optional<std::variant<std::string, SkPaint>>>::toJSI(runtime, arg.backgroundColor));
      obj.setProperty(runtime, "borderRadius", JSIConverter<std::optional<double>>::toJSI(runtime, arg.borderRadius));
      obj.setProperty(runtime, "borderBottomLeftRadius", JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::toJSI(runtime, arg.borderBottomLeftRadius));
      obj.setProperty(runtime, "borderBottomRightRadius", JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::toJSI(runtime, arg.borderBottomRightRadius));
      obj.setProperty(runtime, "borderTopLeftRadius", JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::toJSI(runtime, arg.borderTopLeftRadius));
      obj.setProperty(runtime, "borderTopRightRadius", JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::toJSI(runtime, arg.borderTopRightRadius));
      obj.setProperty(runtime, "strokeCap", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::StrokeCap>>::toJSI(runtime, arg.strokeCap));
      obj.setProperty(runtime, "strokeJoin", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::StrokeJoin>>::toJSI(runtime, arg.strokeJoin));
      obj.setProperty(runtime, "strokeMiter", JSIConverter<std::optional<double>>::toJSI(runtime, arg.strokeMiter));
      obj.setProperty(runtime, "blendMode", JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::BlendMode>>::toJSI(runtime, arg.blendMode));
      obj.setProperty(runtime, "antiaAlias", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.antiaAlias));
      obj.setProperty(runtime, "dither", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.dither));
      obj.setProperty(runtime, "opacity", JSIConverter<std::optional<double>>::toJSI(runtime, arg.opacity));
      obj.setProperty(runtime, "transform", JSIConverter<std::optional<std::vector<std::variant<margelo::nitro::RNSkiaYoga::TransformRotateX, margelo::nitro::RNSkiaYoga::TransformRotateY, margelo::nitro::RNSkiaYoga::TransformRotateZ, margelo::nitro::RNSkiaYoga::TransformScale, margelo::nitro::RNSkiaYoga::TransformScaleX, margelo::nitro::RNSkiaYoga::TransformScaleY, margelo::nitro::RNSkiaYoga::TransformTranslateX, margelo::nitro::RNSkiaYoga::TransformTranslateY, margelo::nitro::RNSkiaYoga::TransformSkewX, margelo::nitro::RNSkiaYoga::TransformSkewY>>>>::toJSI(runtime, arg.transform));
      obj.setProperty(runtime, "origin", JSIConverter<std::optional<std::tuple<double, double>>>::toJSI(runtime, arg.origin));
      obj.setProperty(runtime, "matrix", JSIConverter<std::optional<shared_ptr<SkMatrix>>>::toJSI(runtime, arg.matrix));
      obj.setProperty(runtime, "clip", JSIConverter<std::optional<std::variant<SkPath, SkRRect, SkRect>>>::toJSI(runtime, arg.clip));
      obj.setProperty(runtime, "invertClip", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.invertClip));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::canConvert(runtime, obj.getProperty(runtime, "alignContent"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::canConvert(runtime, obj.getProperty(runtime, "alignItems"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Align>>::canConvert(runtime, obj.getProperty(runtime, "alignSelf"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "aspectRatio"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderBottomWidth"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderEndWidth"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderLeftWidth"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderRightWidth"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderStartWidth"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderTopWidth"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderWidth"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderHorizontalWidth"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderVerticalWidth"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "bottom"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::BoxSizing>>::canConvert(runtime, obj.getProperty(runtime, "boxSizing"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Direction>>::canConvert(runtime, obj.getProperty(runtime, "direction"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Display>>::canConvert(runtime, obj.getProperty(runtime, "display"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "end"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "flex"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "flexBasis"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::FlexDirection>>::canConvert(runtime, obj.getProperty(runtime, "flexDirection"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "rowGap"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "gap"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "columnGap"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "flexGrow"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "flexShrink"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::FlexWrap>>::canConvert(runtime, obj.getProperty(runtime, "flexWrap"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "height"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::JustifyContent>>::canConvert(runtime, obj.getProperty(runtime, "justifyContent"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "left"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "margin"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "marginBottom"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "marginEnd"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "marginLeft"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "marginRight"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "marginStart"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "marginTop"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "marginHorizontal"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "marginVertical"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "maxHeight"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "maxWidth"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "minHeight"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "minWidth"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Overflow>>::canConvert(runtime, obj.getProperty(runtime, "overflow"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "padding"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "paddingBottom"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "paddingEnd"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "paddingLeft"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "paddingRight"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "paddingStart"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "paddingTop"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "paddingHorizontal"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "paddingVertical"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::Position>>::canConvert(runtime, obj.getProperty(runtime, "position"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "right"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "start"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "top"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "insetHorizontal"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "insetVertical"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "inset"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, double>>>::canConvert(runtime, obj.getProperty(runtime, "width"))) return false;
      if (!JSIConverter<std::optional<std::variant<std::string, SkPaint>>>::canConvert(runtime, obj.getProperty(runtime, "backgroundColor"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "borderRadius"))) return false;
      if (!JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::canConvert(runtime, obj.getProperty(runtime, "borderBottomLeftRadius"))) return false;
      if (!JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::canConvert(runtime, obj.getProperty(runtime, "borderBottomRightRadius"))) return false;
      if (!JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::canConvert(runtime, obj.getProperty(runtime, "borderTopLeftRadius"))) return false;
      if (!JSIConverter<std::optional<std::variant<double, margelo::nitro::RNSkiaYoga::SkPoint>>>::canConvert(runtime, obj.getProperty(runtime, "borderTopRightRadius"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::StrokeCap>>::canConvert(runtime, obj.getProperty(runtime, "strokeCap"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::StrokeJoin>>::canConvert(runtime, obj.getProperty(runtime, "strokeJoin"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "strokeMiter"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::RNSkiaYoga::BlendMode>>::canConvert(runtime, obj.getProperty(runtime, "blendMode"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "antiaAlias"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "dither"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "opacity"))) return false;
      if (!JSIConverter<std::optional<std::vector<std::variant<margelo::nitro::RNSkiaYoga::TransformRotateX, margelo::nitro::RNSkiaYoga::TransformRotateY, margelo::nitro::RNSkiaYoga::TransformRotateZ, margelo::nitro::RNSkiaYoga::TransformScale, margelo::nitro::RNSkiaYoga::TransformScaleX, margelo::nitro::RNSkiaYoga::TransformScaleY, margelo::nitro::RNSkiaYoga::TransformTranslateX, margelo::nitro::RNSkiaYoga::TransformTranslateY, margelo::nitro::RNSkiaYoga::TransformSkewX, margelo::nitro::RNSkiaYoga::TransformSkewY>>>>::canConvert(runtime, obj.getProperty(runtime, "transform"))) return false;
      if (!JSIConverter<std::optional<std::tuple<double, double>>>::canConvert(runtime, obj.getProperty(runtime, "origin"))) return false;
      if (!JSIConverter<std::optional<shared_ptr<SkMatrix>>>::canConvert(runtime, obj.getProperty(runtime, "matrix"))) return false;
      if (!JSIConverter<std::optional<std::variant<SkPath, SkRRect, SkRect>>>::canConvert(runtime, obj.getProperty(runtime, "clip"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "invertClip"))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
